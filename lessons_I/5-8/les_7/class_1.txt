План:

	1.	Процедурное и объектно-ориентированное
			программирование;
	2.	Концепция классов;
	3.	Определение и реализация класса;
	4.	Открытый и закрытый доступ к классу;
	5.	Данные-члены класса;
	6.	Методы класса (также называемые
			функциями-членами класса);
	7.	Создание и использование объектов класса;
	8.	Конструкторы и деструкторы класса;
	9.	Функции-члены const;
	10.	Указатель this;
	11.	Создание массивов объектов;
	12.	Область видимости класса;
	13.	Абстрактные типы данных;

Теория:

		Объектно-ориентированное программирование (ООП) — это особый 
концептуальный подход к проектированию программ, и C++ расширяет язык С средствами,
облегчающими применение такого подхода. Ниже перечислены наиболее важные 
характеристики ООП:
	• абстракция;
	• инкапсуляция и сокрытие данных;
	• полиморфизм;
	• наследование;
	• повторное использование кода.

	Класс — это единственное наиболее важное расширение C++, предназначенное для
реализации этих средств и связывающее их между собой.

	При процедурном подходе вы сначала концентрируетесь на 
процедурах, которым должны следовать, а только потом думаете о том, как представить
данные.
		При объектно-ориентированном подходе вы концентрируетесь на
объекте, как его представляет пользователь, думая о данных, которые нужны для 
описания объекта, и операциях, описывающих взаимодействие пользователя с данными.
После разработки описания интерфейса вы перейдете к выработке решений о том,
как реализовать этот интерфейс и как организовать хранение данных.
		
		Класс — это двигатель C++, предназначенный для трансляции абстракци в 
пользовательские типы. Он комбинирует представление данных и методов для 
манипулирования этими данными в пределах одного аккуратного пакета.
	
		Обычно спецификация класса состоит из двух частей.
	• Объявление класса, описывающее компоненты данных в терминах членов 
данных, а также открытый интерфейс в терминах функций-членов, называемых
методами.
	• Определения методов класса, которые описывают, как реализованы определенные
функции-члены.
Грубо говоря, объявление класса предоставляет общий обзор класса, в то время как
определения методов снабжают необходимыми деталями.
		
		Интерфейс — это совместно используемая часть, предназначенная для взаимодействия
двух систем, например, между компьютером и принтером или между пользователем и 
компьютерной программой.

		В отношении классов мы говорим об открытом
интерфейсе. В этом случае потребителем его является программа, использующая класс,
система взаимодействия состоит из объектов класса, а интерфейс состоит из методов, 
предоставленных тем, кто написал этот класс. Интерфейс позволяет вам, как программисту,
написать код, взаимодействующий с объектами класса, и таким образом, дает программе
возможность взаимодействовать с объектами класса.
		Новыми (помимо class) также являются ключевые слова private и public. Эти метки 
позволяют управлять доступом к членам класса. Любая программа, которая использует объект
определенного класса, может иметь непосредственный доступ к членам из 
раздела public. Доступ к членам объекта из раздела private программа может получить
только через открытые функции-члены из раздела public.
		Открытые функции-члены действуют в качестве
посредников между программой и закрытыми членами объекта; они предоставляют
интерфейс между объектом и программой. Эта изоляция данных от прямого доступа
со стороны программы называется сокрытием данных. (В C++ имеется третье 
ключевое слово для управления доступом — protected -> о нём при наследвании классов)
		
		рис 10.1

		Объявлять члены класса — будь они элементами данных или функциями-членами —
можно как в открытом (public), так и в закрытом (private) разделе класса. Но 
поскольку одним из главных принципов ООП является сокрытие данных, то единицы
данных обычно размещаются в разделе private. Функции-члены, которые образуют
интерфейс класса, размещаются в разделе public; в противном случае вызвать эти
функции из программы не удастся.

		Каждый вновь созданный вами объект содержит хранилище для собственных 
внутренних переменных-членов класса, однако все объекты одного класса разделяют 
общий набор методов, по одной копии каждого.

		рис 10.1

		Целью языка C++ является сделать применение классов насколько возможно
простым — подобно базовым встроенным типам вроде int и char. Создавать объект
класса можно за счет объявления переменной этого класса либо использования 
операция new для размещения в памяти объекта этого класса. Объекты можно передавать в
аргументах, возвращать их из функций, присваивать один объект другому.

		Первый шаг в проектировании класса заключается в предоставлении объявления
класса. Объявление класса смоделировано на основе объявления структуры и может
включать в себя данные-члены и функции-члены. Объявление имеет раздел private,
и члены, объявленные в этом разделе, могут быть доступны только через функции-
члены. Объявление также содержит раздел public, и объявленные в нем члены 
могут быть непосредственно доступны программе, использующей объекты класса. Как
правило, данные-члены попадают в закрытый раздел, а функции-члены — в открытый,
поэтому типичное объявление класса имеет следующую форму:

class имяКласса
{
	private:
		объявления данных-членов
	public:
		прототипы функций-членов
};

		Содержимое открытого раздела включает абстрактную часть проектного 
решения — открытый интерфейс. Инкапсуляция данных в закрытом разделе защищает их
целостность и называется сокрытием данных. Таким образом, использование 
классов — это способ, который предлагает C++ для облегчения реализации абстракций,
сокрытия данных и инкапсуляции ООП.
Второй шаг в спецификации класса — это реализация функций-членов класса.
Вместо прототипов в объявление можно включать полное определение функций, 
однако общепринятая практика состоит в том, чтобы определять функции отдельно, за
исключением наиболее простых. В этом случае вам понадобится операция разрешения
контекста для индикации того, к какому классу данная функция-член принадлежит.
Например, предположим, что класс Bozo имеет функцию-член Retort (), которая 
возвращает указатель на тип char. Заголовок функции должен выглядеть примерно так:
	char * Bozo::Retort ()
Другими словами, Retort () — не только функция типа char *, это функция типа
char *, принадлежащая классу Bozo. Полное, или уточненное, имя функции будет 
выглядеть как Bozo: :Retort(). Имя Retort (), с другой стороны, является сокращением
уточненного имени, и оно должно использоваться только в определенных случаях, 
таких как в коде методов класса.
Другой способ описания этой ситуации — это говорить о том, что Retort имеет
область видимости класса, поэтому необходима операция разрешения контекста для
уточнения имени, когда оно встречается вне объявления и вне методов класса.
Для создания объекта, который является частным примером класса, применяется
имя класса, как если бы оно было именем типа:
Bozo bozetta;
Это работает потому, что класс является типом, определенным пользователем.
Функция-член класса, или метод, вызывается с использованием объекта класса. Это
делается с помощью операции членства (точки):
	cout << bozetta.Retort();
Код вызывает функцию-член Retort (), и всякий раз, когда код этой функции 
обращается к определенным данным-членам, используются значения членов объекта
bozetta.

		Конструктор — это специальная функция-член класса, которая вызывается всякий
раз при создании объекта данного класса. Конструктор класса имеет то же имя, что и
класс, но благодаря возможностям перегрузки функций, существует возможность 
создавать более одного конструктора с одним и тем же именем и разным набором 
аргументов. Кроме того, конструктор не имеет объявленного типа. Обычно конструктор
используется для инициализации членов объекта класса. Ваша инициализация должна
соответствовать списку аргументов конструктора. Например, предположим, что класс
Bozo имеет следующий прототип для конструктора:
Bozo(const char * fname, const char * lname); // прототип конструктора
В этом случае его можно использовать для инициализации объекта следующим 
образом:
	Bozo bozetta = Bozo("Bozetta", "Biggens"); // основная форма
	Bozo fufu("Fufu", "O'Dweeb"); // сокращенная форма
	Bozo *pc = new Bozo("Popo", "Le Peu") ; // динамический объект

		Конструктор по умолчанию не имеет аргументов и используется, когда вы создаете
объект без явной его инициализации. Если вы не предоставляете ни одного 
конструктора, то компилятор создаст конструктор по умолчанию самостоятельно. В 
противном случае вы обязаны определить собственный конструктор по умолчанию. Он может 
либо не иметь аргументов, либо предусматривать значения по умолчанию для
всех аргументов:
	Bozo (); // прототип конструктора по умолчанию
	Bistro(const char *s = "Chez Zero"); // значение по умолчанию для класса
	
	Bozo bibi; // используется конструктор по умолчанию
	Bozo *pb = new Bozo; // используется конструктор по умолчанию
		
		Подобно тому, как при создании объекта вызывается конструктор, деструктор 
вызывается при его уничтожении. Для класса допускается наличие только одного 
деструктора. Он не имеет возвращаемого типа (даже void), не имеет аргументов, и его
имя состоит из имени класса с предшествующей тильдой (~). Например, деструктор
класса Bozo имеет следующий прототип:
		-Bozo(); // деструктор класса
		
		Деструкторы классов, в которых используется операция delete, становятся 
необходимыми, когда в конструкторах классов применяется операция new.
____________________________________________________________________________________________

		В ООП основное внимание акцентируется на представлении данных. Первый
шаг к решению проблем программирования с помощью 
объектно-ориентированного подхода заключается в описании данных в терминах их интерфейса с 
программой, указывающего, как их использовать. После этого должен быть спроектирован
класс, который реализует такой интерфейс. Обычно закрытые данные-члены хранят
информацию, в то время как открытые функции-члены, также называемые 
методами, предлагают единственный способ доступа к данным. Класс комбинирует 
данные и методы в единый модуль, а закрытый способ доступа обеспечивает сокрытие
данных.
		Обычно объявление класса разделяется на две части, как правило, сохраняемые в
разных файлах. Объявление класса с методами, представленными с помощью 
прототипов функций, попадает в заголовочный файл. Исходный код, составляющий 
функции-члены, попадает в файл методов. Такой подход позволяет отделить описание 
интерфейса от деталей реализации.
		В принципе для того, чтобы использовать класс, необходимо знать только его
открытый интерфейс. Конечно же, можно просматривать реализацию (если только
класс не поставляется в скомпилированном виде), однако программа не должна 
зависеть от деталей реализации класса, как и знать, что какое-то значение, например, 
хранится в виде int. До тех пор, пока программа и класс взаимодействуют только через
методы, определенные в интерфейсе, вы вольны совершенствовать обе части 
независимо, не заботясь о нежелательном взаимодействии.
		Класс — это определяемый пользователем тип, а объект — экземпляр класса. Это
значит, что объект является переменной этого типа или эквивалентом переменной,
такой как выделенный операцией new участок памяти в соответствии со 
спецификациями класса. C++ старается сделать применение пользовательских типов настолько
же простым, как и стандартных типов, поэтому можно объявлять объекты, указатели
на объекты и массивы объектов. Вы можете передавать объекты в виде аргументов,
возвращать их в качестве значений из функций и присваивать один объект другому
объекту того же типа. Если предоставлен метод конструктора, объекты могут быть
инициализированы во время создания. Если предусмотрен деструктор, он будет 
вызван при уничтожении объектов.
		Каждый объект содержит собственную копию набора данных из объявления 
класса, но все объекты совместно используют методы класса. Если mrobject — это имя 
определенного объекта, a tryme () — его функция-член, то вызывать эту функцию 
можно с помощью операции членства (точки), т.е. mrobject. tryme (). В терминологии
ООП такой вызов называется отправкой сообщения tryme () объекту mrobject.
Любая ссылка на данные-члены класса в методе try_me() затем 
применяется к данным-членам объекта mrobject. Аналогичным образом, вызов функции
i_ob j ect. try_me () получает доступ к данным-членам объекта i_obj ect.
Если нужно, чтобы функция-член взаимодействовала с более чем одним объектом,
ей следует передать дополнительные объекты в виде аргументов. Если метод 
нуждается в явном доступе к объекту, который его вызвал, он может сделать это через 
указатель this. Указатель this устанавливается в адрес вызывающего объекта, поэтому
выражение *this является псевдонимом самого объекта.
		Классы хорошо подходят для описания абстрактных типов данных (ADT). 
Интерфейс открытых функций-членов предоставляет службы, описанные ADT, а закрытые
члены и код методов класса являются реализацией, скрытой от клиентов класса.
