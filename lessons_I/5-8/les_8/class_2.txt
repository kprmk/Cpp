План:
	
	1 Перегрузка операций;
	2 Дружественные функции;
	3 Перегрузка операции << для вывода;
	4 Члены состояния;
	5 Использование rand () для генерации
		случайных чисел;
	6 Автоматические преобразования и приведения;
		типов для классов;
	7 Функции преобразования классов;
	8. Динамическое выделение памяти для членов класса;
	9. Явные и неявные конструкторы копирования;
	10. Явные и неявные перегруженные операции
		присваивания;
	11. Что необходимо делать при использовании операции
		new в конструкторе;

Теория:
_____________________________________________________________________________________

		Обычно единственным способом доступа к закрытым членам класса является 
использование методов класса. В C++ это ограничение ослабляется за счет технологии
дружественных функций. Чтобы сделать функцию другом класса, ее необходимо 
объявить внутри объявления класса и предварить объявление ключевым словом friend.
C++ расширяет перегрузку операций возможностью определять специальные 
функции операций, которые описывают, как конкретная операция применяется с 
конкретным классом. Функция операции может быть функцией-членом класса либо 
дружественной функцией. (Некоторые операции могут быть только членами класса.) C++
позволяет вызывать функцию операции как непосредственным обращением к этой
функции, так и применением операции в обычном синтаксисе. Функция операции для
операции ор имеет следующую форму:
	operator op (список-аргументов)
	
	Cписок-аргументов представляет операнды операции. Если функция операции 
является функцией-членом класса, то первый операнд — это вызывающий объект, не 
являющийся частью список-аргументов. Например, перегружаz операцию сложения, 
определив функцию operator* () в классе Vector. Если up,
right и result — три вектора, для сложения векторов можно использовать любой из
следующих операторов:
	result = up.operator*(right) ;
	result = up + right;
Во втором варианте тот факт, что операнды up и right имеют тип Vector, 
заставляет C++ применять определение сложения, объявленное в классе Vector.
Когда функция операции является функцией-членом, первый операнд 
представляет собой объект, вызывающий эту функцию. Так, например, в приведенных 
выражениях объект up является вызывающим объектом. Если хотите определить функцию
операции так, чтобы первый операнд не был объектом класса, необходимо объявить
ее как дружественную функцию. Тогда ей можно будет передавать операнды в любом
порядке.
Одна из наиболее часто применяемых задач перегрузки — определение операции
<< для ее применения с объектом сout с целью отображения содержимого объектов.
Чтобы позволить объекту ostream быть первым операндом, функция операции 
определяется как дружественная. Чтобы позволить перегруженной операции сцепляться
с самой собой, в качестве возвращаемого типа этой функции указывается ostream &.
Ниже приведена общая форма, удовлетворяющая этим требованиям:
ostream & operator<<(ostream & os, const c_name & obj)
{
os «... ; // отображение содержимого объекта
return os;
}
Однако если класс имеет методы, возвращающие значения данных-членов, 
которые нужно отобразить, их можно использовать в operator<< () вместо прямого 
доступа. В этом случае функция не обязана быть дружественной.
C++ позволяет устанавливать преобразования типов из класса в заданный тип и
обратно. Прежде всего, любой конструктор класса, принимающий единственный 
аргумент, может служить функцией преобразования, преобразуя тип аргумента в тип
класса. Конструктор вызывается автоматически, когда значение типа аргумента 
присваивается объекту. Например, предположим, что имеется класс String с 
конструктором, который принимает один аргумент типа char *. Тогда если bean — объект типа
String, то можно записать следующий оператор:
	bean = "pinto"; // преобразует тип char * в тип String

		Функция не имеет объявленного типа возврата, не 
принимает аргументов и возвращает преобразованное значение (несмотря на отсутствие
возвращаемого типа). Например, функция для преобразования типа Vector в тип
double должна иметь такую форму:
	Vector::operator double ()
	{
		return значение;
	}
Опыт показывает, что часто лучше не полагаться на функции неявного 
преобразования.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операцию new можно использовать в конструкторе класса, чтобы выделить память
под данные, а затем присвоить адрес этой памяти какому-то члену класса. Это 
позволяет классу, например, работать со строками различных размеров без жесткого 
кодирования заранее установленного размера. Но операция new в конструкторах класса 
может стать и источником проблем во время прекращения существования объекта. Если
объект имеет указатели-члены, которые указывают на память, выделенную операцией
new, то освобождение памяти, которую занимал объект, не освобождает автоматически
память, на которую указывают указатели-члены этого объекта. Поэтому если в 
конструкторе класса выделяется память с помощью операции new, то в деструкторе класса
необходимо использовать операцию delete для освобождения этой памяти. Тогда при
уничтожении объекта автоматически запускается и удаление указываемой памяти.
Кроме того, объекты с членами, которые указывают на память, распределенную
операцией new, являются источником сложностей при инициализации одного 
объекта другим либо при присваивании одного объекта другому. По умолчанию в C++ 
применяются почленная инициализация и присваивание, когда полученные объекты 
являются точными копиями членов исходных объектов. Если исходный член указывает
на блок данных, то и член в копии указывает на тот же самый блок. Если программа
в конце работы удаляет два объекта, деструктор класса пытается удалить один и тот
же блок дважды, что является ошибкой. Выходом служит определение специального
конструктора копирования, который переопределяет инициализацию, и 
перегруженной операции присваивания. В любом случае новое определение должно создавать
копии всех данных, на которые имеются указатели, чтобы новый объект указывал на
эти копии. Тогда старый и новый объекты будут указывать на отдельные (хотя и 
одинаковые) данные, не перекрывающие друг друга. Те же рассуждения применяются и
к операции присваивания. Во всех случаях требуется создание глубокой копии — т.е.
необходимо копировать сами данные, а не только указатели на них.
Если объект имеет автоматическую или внешнюю память, то деструктор для 
этого объекта вызывается автоматически, когда объект прекращает свое существование.
Если память для объекта выделяется операцией new, и его адрес присваивается 
указателю, то деструктор для данного объекта вызывается автоматически при применении
операции delete к указателю. Однако если память для объектов класса выделять с
помощью операции new с размещением, а не обычной new, то на программиста 
возлагается ответственность за явный вызов деструктора с указателем на такой объект, C++
позволяет помещать определения структур, классов и перечислений внутри класса.
Подобные вложенные типы действительны только в пределах класса — т.е. локальны
для класса — и не конфликтуют со структурами, классами и перечислениями с таким
же именем, определенным где-либо еще.
