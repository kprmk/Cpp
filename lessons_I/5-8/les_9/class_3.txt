План:

	1. Наследование как отношение является
	2. Открытое порождение одного класса от другого
	3. Защищенный доступ
	4. Списки инициализаторов членов в конструкторах
	5. Повышающее и понижающее приведение типа
	6. Виртуальные функции-члены
	7. Раннее (статическое) связывание и позднее
		(динамическое) связывание
	8. Абстрактные базовые классы
	9. Чистые виртуальные функции
	10. Когда и как использовать открытое наследование
	11. Отношения содержит
	12. Классы с объектами-членами (включение)
	13. Класс шаблона valarray
	14. Закрытое и защищенное наследование
	15. Множественное наследование
	16. Виртуальные базовые классы
	17. Создание шаблонов классов
	18. Использование шаблонов классов
	19. Специализации шаблонов

Теория:
_____________________________________________________________________________________

		Наследование позволяет адаптировать программный код к конкретным 
потребностям с помощью определения нового (производного) класса из существующего 
(базового). Открытое наследование моделирует отношение является, а это означает, что
объект производного класса должен быть разновидностью объекта базового класса.
Как часть модели является, производный класс наследует члены данных и 
большинство методов базового класса. Однако производный класс не наследует конструкторы,
деструкторы и операции присваивания базового класса. Производный класс может
обращаться к открытым и защищенным членам базового класса непосредственно, а к
закрытым членам базового класса — через открытые и защищенные методы базового
класса. Затем в класс можно добавлять новые члены данных и методы, а также 
использовать производный класс в качестве базового для дальнейшей разработки.
В каждом производном классе должен быть собственный конструктор. Когда 
программа создает объект производного класса, она сначала вызывает конструктор 
базового класса, а затем конструктор производного класса. При удалении объекта программа
сначала вызывает деструктор производного класса, а затем деструктор базового класса.
Если класс предполагается использовать в качестве базового, то можно 
использовать защищенные члены, а не закрытые — тогда производные классы будут иметь 
прямой доступ к данным-членам. Однако применение закрытых членов обычно снижает
вероятность появления программных ошибок. Если в производном классе 
планируется переопределение какого-то метода базового класса, его необходимо сделать 
виртуальной функцией, объявив его с ключевым словом virtual. Это позволяет управлять
объектами, на которые указывают указатели или ссылки, на основе типа объекта, а не
на основе типа ссылки или указателя. В частности, должен быть виртуальным 
деструктор для базового класса.
Возможно, понадобится определить абстрактный базовый класс, который 
определяет интерфейс без деталей реализации. Например, можно определить абстрактный
класс Shape (Фигура), а от него порождать отдельные классы фигур, такие как Circle
(Круг) и Square (Прямоугольник). Абстрактный базовый класс должен содержать
хотя бы один чистый виртуальный метод. Для объявления чистой виртуальной 
функции нужно в объявлении после закрывающей скобки добавить конструкцию = 0:
virtual double area() const = 0;
Определять чистые виртуальные методы не нужно; кроме того, невозможно 
создать объект класса, который содержит чистые виртуальные члены. Чистые 
виртуальные функции служат только для определения общего интерфейса, который будет 
использоваться производными классами.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
В C++ имеется несколько средств для повторного использования кода. 
Общедоступное наследование, рассмотренное в главе 13, позволяет моделировать 
отношение является, когда производные классы могут повторно использовать код базовых
классов. Закрытое и защищенное наследование также позволяет повторно 
использовать код базовых классов, но в этом случае моделируется отношение содержит.
При закрытом наследовании открытые и защищенные члены базового класса 
становятся закрытыми членами производного класса. При защищенном наследовании
открытые и защищенные члены базового класса становятся защищенными членами
производного класса. То есть в обоих случаях открытый интерфейс базового класса
становится внутренним интерфейсом для производного класса. Иногда это 
называют наследованием реализации, а не интерфейса, т.к. производный объект не может
явно использовать интерфейс базового класса. Поэтому производный объект 
нельзя считать разновидностью базового объекта. А из-за этого указатель или ссылку на
базовый объект нельзя применять для ссылки на объект производного класса без
явного приведения типа.
Еще один способ повторного использования кода класса — разработка класса,
члены которого сами являются объектами. Этот подход называется включением, 
иерархическим представлением или композицией и также моделирует отношение содержит.
Включение проще реализовать и применять, чем закрытое или защищенное 
наследование, и поэтому оно используется чаще. Однако возможности закрытого и 
защищенного наследования слегка различаются. Например, наследование позволяет 
производному классу обращаться к защищенным членам базового класса. Оно также позволяет
производному классу переопределять виртуальные функции, унаследованные от базового класса.
Включение не является разновидностью наследования и поэтому не 
обеспечивает таких возможностей. Зато включение удобнее, если нужно создать несколько
объектов одного класса. Например, класс Country (Страна) может содержать массив
объектов State (Штат).
Множественное наследование позволяет использовать в классе код нескольких 
других классов. Закрытое и защищенное множественное наследование приводит к 
созданию отношений содержит, а открытое множественное наследование — к созданию
отношений является. Применение множественного наследования приводит к 
возникновению проблем, связанных с неоднозначностью имен и неоднозначным 
наследованием базового класса. Для разрешения неоднозначности имен можно использовать
квалификаторы класса, а для преодоления неоднозначности наследования — 
виртуальные базовые классы. Однако виртуальные базовые классы вводят новые правила для
списка инициализации в конструкторах и для разрешения неоднозначности.
Шаблоны классов позволяют создать общую структуру класса, в которой тип (как
правило, тип члена) представлен параметром типа. Обычно шаблон выглядит 
следующим образом:

template <class T>
class Ic
{
	Т v;
	public:
	Ic (const T & val) : v(val) { }
};

Здесь T — параметр типа, и он играет роль заполнителя для реального типа, 
который будет указан позднее. (Этот параметр может иметь любое допустимое в C++ имя,
но обычно применяется Т или Туре.) В данном контексте слово class можно 
заменить словом type name:

template <typename T> // эквивалентно template <class T>
class Rev { . . . } ;

Определение класса (создание экземпляра) генерируется при объявлении 
объекта класса и указании конкретного типа. Например, следующее объявление указывает
компилятору сгенерировать объявление класса, в котором каждое вхождение 
параметра типа Т в шаблоне заменено типом short:

class Ic<short> sic; // неявное создание экземпляра

В этом случае именем класса будет Ic<short>, а не Іс. Объявление Ic<short> 
называется специализацией шаблона. В данном случае это неявное создание экземпляра.
Явное создание экземпляра происходит при объявлении конкретной 
специализации класса с помощью ключевого слова template:
template class IC<int>; // явное создание экземпляра
В этом случае компилятор использует общий шаблон для генерации 
специализации Ic<int>, даже если еще не затребован ни один объект этого класса.
Можно создать явную специализацию — специализированное определение класса,
которое переопределяет определение шаблона. Для этого определение класса 
начинается с конструкции templateo, потом указывается имя шаблонного класса, а за
ним — угловые скобки, содержащие тип требуемой специализации.
Например, можно создать специализированный класс Іс для указателей на символы:

template о class Ic<char *>.
{
char * str;
public:
Ic (const char * s) : str(s) { }
} ;

Тогда объявление следующего вида будет использовать не общий шаблон, а 
специализированное определение для chic:

class Ic<char *> chic;

Шаблон класса может задавать несколько общих типов и может иметь нетииизиро-
ванные параметры:

template <class T, class TT, int n>
class Pals {...};

Показанное ниже объявление сгенерирует неявное создание экземпляра, заменив
Т на double, TT на string и п на 6:

Pals<double, string, 6> mix;

Шаблон класса может иметь параметры, которые сами являются шаблонами:

template <template <typename T> class CL, typename U, int z>
class Trophy {...};

Здесь z — это значение типа int, U — имя типа, a CL — шаблон класса, 
определенного конструкцией template <typename T>.
Шаблоны класса могут быть специализированными частично:

template <class T> Pals<T, Т, 10> {...};
template <class Т, class TT> Pals<T, TT, 100> {...};
template <class T, int n> Pals <T, T*, n> {...};

В первом примере создается специализация, в которой оба типа одинаковы, а п
имеет значение 6. Во втором примере создается специализация для п, равного 100.
В третьем примере создается специализация, в которой второй тип является 
указателем на первый тип.
Шаблонные классы могут быть членами других классов, структур и шаблонов.
Главная цель создания всех рассмотренных методов — предоставить программисту
возможность повторного использования проверенного кода без его ручного 
копирования. Это упрощает программирование и повышает надежность программ.
